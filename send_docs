#!/usr/bin/env bash


# ==============================================================================
# CONFIGURAÇÕES E VERSÃO
# ==============================================================================
VERSION="1.0.2"
REPO_URL="https://raw.githubusercontent.com/gui-carrazzoni/SO/main/send_docs" # Link do arquivo RAW (sem extensão)
CREDS_FILE="$HOME/.ppgec_creds"
LOGFILE="$PWD/envios.log"
DOMINIO="@poli.br"
SMTP_SERVER="smtp://smtp.gmail.com:587"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# ==============================================================================
# FUNÇÕES UTILITÁRIAS
# ==============================================================================

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') | $1" | tee -a "$LOGFILE"
}

erro() {
    echo -e "${RED}ERRO: $1${NC}"
    exit 1
}

# Remove acentos, espaços e deixa minúsculo
clean_string() {
    echo "$1" | iconv -f utf-8 -t ascii//TRANSLIT | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]'
}

# Gera iniciais ignorando preposições
get_initials() {
    local nome="$1"
    local inic=""
    local ignore_list=("de" "da" "do" "dos" "das" "e" "o")

    # Converte para array
    read -ra palavras <<< "$nome"

    for palavra in "${palavras[@]}"; do
        p_clean=$(echo "$palavra" | tr '[:upper:]' '[:lower:]')
        skip=false
        for ign in "${ignore_list[@]}"; do
            [[ "$p_clean" == "$ign" ]] && skip=true
        done

        if ! $skip; then
            inic+="${palavra:0:1}"
        fi
    done
    echo "$inic"
}

# ==============================================================================
# AUTO-UPDATE
# ==============================================================================
check_update() {
    echo -e "${CYAN}Verificando atualizações...${NC}"

    # Baixa o cabeçalho do arquivo remoto para pegar a versão
    remote_code=$(curl -s "$REPO_URL")

    if [[ -z "$remote_code" ]]; then
        erro "Não foi possível conectar ao repositório."
    fi

    # Extrai a versão usando regex
    if [[ "$remote_code" =~ VERSION=\"([0-9.]+)\" ]]; then
        remote_ver="${BASH_REMATCH[1]}"

        # Compara versões (lógica simples de sort -V)
        if [[ "$(printf '%s\n' "$VERSION" "$remote_ver" | sort -V | tail -n1)" != "$VERSION" ]]; then
            echo -e "${GREEN}Nova versão encontrada: $remote_ver (Atual: $VERSION)${NC}"
            echo -n "Atualizando..."

            # Verifica se tem permissão de escrita no script atual
            if [[ ! -w "$0" ]]; then
                echo -e "\n${RED}Sem permissão de escrita em $0.${NC}"
                echo "Por favor, rode: sudo $0 --update"
                exit 1
            fi

            # Sobrescreve o script
            curl -s "$REPO_URL" > "$0"
            chmod +x "$0"

            echo -e "${GREEN} [CONCLUÍDO]${NC}"
            echo "Execute o comando novamente."
            exit 0
        else
            echo -e "${GREEN}Você já está na versão mais recente ($VERSION).${NC}"
        fi
    else
        echo -e "${YELLOW}Não foi possível ler a versão remota.${NC}"
    fi
}

# ==============================================================================
# GESTÃO DE CREDENCIAIS
# ==============================================================================
manage_credentials() {
    if [[ "$RESET_CREDS" == true ]]; then
        rm -f "$CREDS_FILE"
        echo -e "${YELLOW}Credenciais antigas removidas.${NC}"
    fi

    if [[ ! -f "$CREDS_FILE" ]]; then
        echo -e "\n${CYAN}=== CONFIGURAÇÃO DE PRIMEIRO ACESSO ===${NC}"
        echo "Insira o E-mail (Gmail) e a Senha de App."

        read -p "E-mail: " input_user
        read -s -p "Senha de App: " input_pass
        echo ""

        # Salva no arquivo (formato user:pass)
        echo "$input_user:$input_pass" > "$CREDS_FILE"
        chmod 600 "$CREDS_FILE" # Permissão restrita (apenas o dono lê)

        echo -e "${GREEN}Credenciais salvas em $CREDS_FILE${NC}"
    fi

    # Lê as credenciais do arquivo
    content=$(cat "$CREDS_FILE")
    SMTP_USER="${content%%:*}"
    SMTP_PASS="${content#*:}"
}

# ==============================================================================
# ENVIO DE EMAIL (CURL SMTP)
# ==============================================================================
send_email() {
    local dest="$1"
    local file="$2"
    local filename=$(basename "$file")

    # Codifica anexo em Base64
    local b64_file=$(base64 -w 0 "$file") # -w 0 para Linux (uma linha)

    # Cria estrutura do email
    local mail_content="From: Secretaria PPGEC <$SMTP_USER>
To: $dest
Subject: Seu documento
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=\"BOUNDARY\"

--BOUNDARY
Content-Type: text/plain; charset=\"utf-8\"

Olá,

Segue o documento em anexo.

Atenciosamente.

--BOUNDARY
Content-Type: application/pdf; name=\"$filename\"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=\"$filename\"

$b64_file

--BOUNDARY--"

    # Envia via CURL
    curl -s --url "$SMTP_SERVER" \
        --ssl-reqd \
        --mail-from "$SMTP_USER" \
        --mail-rcpt "$dest" \
        --user "$SMTP_USER:$SMTP_PASS" \
        --upload-file <(echo "$mail_content")

    return $?
}

# ==============================================================================
# HELP
# ==============================================================================
show_help() {
cat <<EOF
${CYAN}USO:${NC}
  enviar --alunos <txt> --docs <zip/pasta> [Opções]

${CYAN}OPÇÕES:${NC}
  --alunos, -a      Arquivo .txt com nomes.
  --docs, -d        Arquivo .zip ou pasta.
  --dry-run         Simulação (não envia).
  --reset-creds     Redefinir senha.
  --update          Atualizar script.
  --help            Ajuda.
EOF
}

# ==============================================================================
# PARSE DE ARGUMENTOS
# ==============================================================================
RESET_CREDS=false
DRY_RUN=false
ALUNOS_FILE=""
DOCS_PATH=""

while [[ "$#" -gt 0 ]]; do
    case $1 in
        --update) check_update; exit 0 ;;
        --help) show_help; exit 0 ;;
        --reset-creds) RESET_CREDS=true ;;
        --dry-run) DRY_RUN=true ;;
        --alunos|-a) ALUNOS_FILE="$2"; shift ;;
        --docs|-d) DOCS_PATH="$2"; shift ;;
        *) echo "Opção desconhecida: $1"; show_help; exit 1 ;;
    esac
    shift
done

# ==============================================================================
# LÓGICA PRINCIPAL
# ==============================================================================

manage_credentials # Carrega ou pede senha

# Se for só reset, sai
if [[ "$RESET_CREDS" == true && -z "$ALUNOS_FILE" ]]; then exit 0; fi

# Validações
if [[ -z "$ALUNOS_FILE" || -z "$DOCS_PATH" ]]; then
    erro "Faltam argumentos obrigatórios. Use --help."
fi

# Tratamento do ZIP
WORK_DIR="$DOCS_PATH"
IS_ZIP=false
if [[ "$DOCS_PATH" == *.zip ]]; then
    IS_ZIP=true
    WORK_DIR="./docs_tmp_$RANDOM"
    echo -e "${CYAN}Extraindo ZIP...${NC}"
    mkdir -p "$WORK_DIR"
    unzip -q "$DOCS_PATH" -d "$WORK_DIR"
fi

# Carrega Alunos
echo "Carregando alunos..."
declare -A alunos_map
while IFS= read -r linha || [[ -n "$linha" ]]; do
    [[ -z "$linha" ]] && continue
    clean=$(clean_string "$linha")
    alunos_map["$clean"]="$linha" # Chave: limpo, Valor: original
done < "$ALUNOS_FILE"

# Simulação
echo -e "\n${CYAN}=== SIMULAÇÃO DE CORRESPONDÊNCIA ===${NC}"
declare -a matches_file
declare -a matches_email

match_count=0
for f in "$WORK_DIR"/*; do
    [[ ! -f "$f" ]] && continue
    fname=$(basename "$f")
    fclean=$(clean_string "$fname")

    for aclean in "${!alunos_map[@]}"; do
        if [[ "$fclean" == *"$aclean"* ]]; then
            original="${alunos_map[$aclean]}"
            iniciais=$(get_initials "$original")
            email="${iniciais,,}$DOMINIO" # ,, força lowercase

            echo -e " [MATCH] $fname  ---->  $email"
            matches_file+=("$f")
            matches_email+=("$email")
            ((match_count++))
        fi
    done
done

echo -e "\nMatches confirmados: $match_count"

if [[ "$DRY_RUN" == true ]]; then
    echo -e "${YELLOW}Modo Dry-Run. Encerrando.${NC}"
    [[ "$IS_ZIP" == true ]] && rm -rf "$WORK_DIR"
    exit 0
fi

read -p "Enviar e-mails reais? (s/n) " confirm
if [[ "$confirm" != "s" ]]; then
    [[ "$IS_ZIP" == true ]] && rm -rf "$WORK_DIR"
    exit 0
fi

# Envio Real
for i in "${!matches_file[@]}"; do
    file="${matches_file[$i]}"
    email="${matches_email[$i]}"

    echo -n "Enviando para $email... "
    if send_email "$email" "$file"; then
        echo -e "${GREEN}[OK]${NC}"
        log "SUCESSO: $email"
    else
        echo -e "${RED}[ERRO]${NC}"
        log "FALHA: $email"
    fi
done

[[ "$IS_ZIP" == true ]] && rm -rf "$WORK_DIR"
echo -e "${CYAN}Concluído.${NC}"